# 출근

## 문제 링크
- https://www.acmicpc.net/problem/13903

## 코드 분석
- 동적 계획법(메모이제이션)
  - 이동할 수 있는 좌표(x,y)를 2차원 배열에 저장하여 메모이제이션에 사용한다.(cache 2차원 배열)
  - 하지만, 각 출발점마다 cache배열을 -1로 초기화해주어야 정확한 답이 도출되어, 시간복잡도가 O(n^3)이 된다. 이는 최대 연산수```1000^3```이므로 제한
  시간을 훨씬 초과한다.
  
- BFS
  - 출발할 수 있는 시작점(세로블럭)의 좌표를 큐에 저장한다.
  - 블럭마다 최소이동거리를 저장한다.(cache 2차원 배열)
  - BFS를 활용하여 이동할 때, 이동할 수 있는 블록에 처음 도달할때에만 이동거리를 갱신해주므로 BFS가 한번 순회하면 모든 좌표에서 최소값을 유지한다.
  - 시간복잡도: 대략 O(n^2)으로 예상된다.
  
## 결과 코드

- 동적 계획법
  - 시간 초과
```
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
#define N 1001
#define min(a,b) ((a) < (b) ? (a) : (b))
//입력 배열
int map[N][N];
//메모이제이션 배열
int cache[N][N];
//이동 규칙을 각각 저장할 배열(x좌표, y좌표)
int mx[10], my[10];
int r, c, n;
//최소값 비교를 위한 변수
int INF = 987654321;

//재귀 호출을 통해 한 출발점에서 마지막 도착점까지 최소값을 반환한다.
int solve(int y, int x)
{
	//기저사례: y좌표가 마지막 도착점에 도달했고, 이동할 수 있는 세로블록 일때,
	if (y == r - 1 && map[y][x]) return 0;
	//메모이제이션
	int &ret = cache[y][x];
	if (ret != -1) return ret;
	ret = INF;
	//이동규칙에 따라 이동할 수 있는 좌표를 검색
	for (int i = 0; i < n; i++) {
		int nexty = y + my[i];
		int nextx = x + mx[i];
		if (nexty >= 0 && nexty < r && nextx >= 0 && nextx < c
			&& map[nexty][nextx]) {
			ret = min(ret, solve(nexty, nextx) + 1);
		}
	}
	return ret;
}

int main(void)
{
	scanf("%d %d", &r, &c);
	for (int i = 0; i < r; i++)
		for (int j = 0; j < c; j++)
			scanf("%d", &map[i][j]);
	scanf("%d", &n);
	for (int i = 0; i < n; i++)
		scanf("%d %d", &my[i], &mx[i]);

	int ans = INF;
	for (int i = 0; i < c; i++) {
		if (map[0][i]) {
			memset(cache, -1, sizeof(cache));
			int cal = solve(0, i);
			//최소값 찾기
			ans = min(ans, cal);
		}
	}
	printf("%d\n", ans);

	return 0;
}
```

- BFS
```
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
#include <algorithm>
using namespace std;
#define N 1001
#define min(a,b) ((a) < (b) ? (a) : (b))
//입력 배열
int map[N][N];
//각 좌표의 최소 이동값을 저장할 배열
//-1: 이동할 수 없는 블록 or 아직 방문하지 않은 블록
int cache[N][N];
//이동 규칙을 각각 저장할 배열(x,y)
int mx[10], my[10];
int r, c, n;
int INF = 987654321;

int main(void)
{
	scanf("%d %d", &r, &c);
	for (int i = 0; i < r; i++)
		for (int j = 0; j < c; j++)
			scanf("%d", &map[i][j]);
	scanf("%d", &n);
	for (int i = 0; i < n; i++)
		scanf("%d %d", &my[i], &mx[i]);

	memset(cache, -1, sizeof(cache));
	int ans = INF;
	//BFS에 활용할 큐 선언
	queue<pair<int, int>> q;
	//출발 할 수 있는 시작점(세로 블록, 1)을 모두 큐에 삽입한다.
	for (int i = 0; i < c; i++)
		if (map[0][i]) {
			q.push(make_pair(0, i));
			cache[0][i] = 0;
		}
	//이동할 수 있는 좌표를 순회한다.(BFS)
	while (!q.empty()) {
		int nowy = q.front().first;
		int nowx = q.front().second;
		q.pop();

		for (int i = 0; i < n; i++) {
			int nexty = nowy + my[i];
			int nextx = nowx + mx[i];
			//전체 크기 범위안에 있고, 세로 블록이며, 아직 방문하지 않은 블록 일 때
			if (nexty >= 0 && nexty < r && nextx >= 0 && nextx < c &&
				map[nexty][nextx] && cache[nexty][nextx] == -1) {
				cache[nexty][nextx] = cache[nowy][nowx] + 1;
				q.push(make_pair(nexty, nextx));
			}
		}
	}
	//마지막 도착점에서 방문한 블록 중 최소값을 찾는다.
	for (int i = 0; i < c; i++)
		if (cache[r - 1][i] > -1)
			ans = min(ans, cache[r - 1][i]);

	printf("%d\n", ans == INF ? -1 : ans);

	return 0;
}
```

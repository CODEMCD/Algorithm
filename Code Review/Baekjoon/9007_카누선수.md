# 카누 선수

## 문제 링크
- https://www.acmicpc.net/problem/9007

## 테스트 케이스
1. 기본 테스트 케이스
- 입력
```
3
300 4
60 52 80 40
75 68 88 63
48 93 48 54
56 73 49 75
8 3
1 2 3
1 2 3
1 2 3
1 2 3
32 2
2 5
9 4
10 20
4 2
```
- 출력
```
301
8
31
```

## 코드 분석
- 완전 탐색 
  - 시간 복잡도: 각 class의 최대 학생 수는 1000명이다. 그러므로 최대 연산수는 ```1000^4```이고, ```O(n^4)```이다. 이는 시간안에 해결할 수 없다.
- 이진 탐색
  - 먼저, class를 (class1, class2), (class3, class4)로 2개로 구분한다.
  - class 1, class2를 더한 모든 경우의 수 ```1000 * 1000```, class3, class4를 더한 모든 경우의 수 ```1000 * 1000```이다.
  - 위의 2개의 class를 더한 모든 경우의 수를 각각 배열에 모두 저장한다.(wsum12[], wsum34[])
  - 한 배열을 모두 순회하는 동안 나머지 한 배열은 이진 탐색으로 순회한다.
  - 조건 1), 특정값과 4명의 학생의 몸무게를 합친 값의 차이가 같은 경우가 있을 때, 특정값보다 작은 경우를 우선한다. (특정값이 300일 때, 298과 302의
  값이 있을 때, 298을 우선시한다.)
  - ___시간 복잡도___: 2개의 class를 더한 모든 경우의 수 ```O(n^2)```, 순차 탐색 + 이진 탐색 ```O(nlogn)```, 결과적으로 ```O(n^2)```이며, 
  최대 연산수 1,000,000이므로 시간안에 해결가능하다.

## 결과 코드
- 링크: [9007번(C++)](https://github.com/CODEMCD/Algorithm/blob/master/Baekjoon/9007.cpp)
```
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#include <limits.h>
using namespace std;
#define N 1001
//절대값 계산
#define abs(a) ((a) >= (0) ? (a) : (-a))
//학생 몸무게를 저장할 배열
int student[4][N];
//class1,2/class3,4를 더한 모든 경우의 수를 저장할 배열
vector<int> wsum12;
vector<int> wsum34;
//minDiff: (특정값 - 현재 4명 학생의 몸무게 합)의 최소값
//findWeight: 특정값에 가장 가까운 몸무게 합
int minDiff, findWeight;

//이진 탐색
int biSearch(int s, int e, int k, int idx)
{
	if (s > e) return -1;
	int mid = (s + e) / 2;

	//특정값에 가까운 몸무게 합 찾기
	int diff = k - (wsum12[idx] + wsum34[mid]);
	if (minDiff > abs(diff)) {
		minDiff = abs(diff);
		findWeight = wsum12[idx] + wsum34[mid];
	}
	//조건 1)
	else if (minDiff == abs(diff) && diff > 0)
		findWeight = wsum12[idx] + wsum34[mid];

	if (k == (wsum12[idx] + wsum34[mid]))
		return mid;
	else if (k > (wsum12[idx] + wsum34[mid]))
		return biSearch(mid + 1, e, k, idx);
	else
		return biSearch(s, mid - 1, k, idx);
}

int main(void)
{
	int tc;
	scanf("%d", &tc);
	while (tc--) {
		minDiff = INT_MAX; findWeight = 0;
		wsum12.clear(); wsum34.clear();
		memset(student, 0, sizeof(student));

		int k, n;
		scanf("%d %d", &k, &n);
		for (int i = 0; i < 4; i++)
			for (int j = 0; j < n; j++)
				scanf("%d", &student[i][j]);
		//2개의 class의 학생들 몸무게를 더한 모든 경우의 수 저장
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				wsum12.push_back(student[0][i] + student[1][j]);
				wsum34.push_back(student[2][i] + student[3][j]);
			}
		}

		//이진 탐색을 위한 오름차순 정렬
		sort(wsum34.begin(), wsum34.end());
		//순차 탐색 + 이진 탐색
		for (int i = 0; i < (int)wsum12.size(); i++)
			biSearch(0, (int)wsum34.size() - 1, k, i);
		printf("%d\n", findWeight);
	}

	return 0;
}
```

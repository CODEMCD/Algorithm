# 극장 좌석
  
## 문제 링크
- https://www.acmicpc.net/problem/2302

## 예외 테스트 케이스
- 입력
```
3
3
1
2
3
```
- 출력
```
1
```

## 코드 분석
- 동적 계획법
  - 규칙을 찾아 반복 동적 계획법으로 푸는 문제이다. (끝까지 규칙을 찾을려고 노력하는게 중요했던 문제였다.)
  - vip석은 고정이기 때문에 제외하고, 자리를 양쪽으로 옮길 수 있는 일반석의 범위를 vip석의 기준으로 나눠 경우의 수를 구한 뒤 모두 곱해준다.
- 기본 테스트 케이스 예제
  - vip석 번호: 4번, 7번
  - 1 2 3 **4** 5 6 **7** 8 9
  - 각 일반석 범위
  ```
  { 1, 2, 3}, { 5, 6 }, { 8, 9 }
  ```
  - 규칙 찾기
  ```
  { 1 } => { 1 }: 1개
  { 1, 2 } => { 1 ,2 }. { 2, 1 }: 2개
  { 1, 2, 3 } => { 1, 2, 3 }, { 1, 3, 2 }, { 2, 1, 3 }: 3개
  { 1, 2, 3, 4 } => { 1, 2, 3, 4 }, { 1, 2, 4, 3}, { 2, 1, 3, 4 }, { 2, 1, 4, 3 }, { 1, 3, 2, 4 }: 5개
  { 1, 2, 3, 4, 5 } => { 1, 2, 3, 4, 5 }, { 1, 2, 3, 5, 4 }, { 1, 2, 4, 3, 5 }, { 1, 3, 2, 4, 5 }, 
                       { 1, 3, 2, 5, 4 }, { 2, 1, 3, 4, 5 }, { 2, 1, 3, 5, 4}, { 2 1 4 3, 5 }: 8개
  ...
  ```
  - 일반 좌석이 늘어날 때 마다 ```1, 2, 3, 5, 8, ...```으로 피보나치의 수와 같이 늘어나는 것을 알 수 있다.
  - 경우의 수 계산
  ```
  { 1, 2, 3 } => 3개
  { 5, 6 } => 2개
  { 8, 9 } => 2개
  ```
  - 위의 경우의 수를 모두 곱해 준 것이 전체 경우의 수가 되므로, ```3 * 2 * 2 = 12```이다.
- 여기서 경우의 수의 최소값은 좌석 번호와 같이 앉는 것이므로 1개이다.
- 시간 복잡도: 피보나치의 수```O(N)```, 경우의 수 계산```O(N)```이며, 미리 피보나치의 수를 모두 구한 뒤 경우의 수를 계산하면 되므로 총 시간복잡도는 ```O(N)```이다.
- 피보나치의 수를 재귀로 풀면 메모리 초과가 난다.

## 결과 코드
```
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <cstdio>
using namespace std;
#define N 41
int vip[N], fibo[N];

void fiboCase()
{
	fibo[0] = 1;  //경우의 수 최소값
	fibo[1] = 1; fibo[2] = 2;
	for (int i = 3; i < N; i++)
		fibo[i] = fibo[i - 1] + fibo[i - 2];
}

int main() 
{
	int n; scanf("%d", &n);
	int m; scanf("%d", &m);
	for (int i = 0; i < m; i++)
		scanf("%d", &vip[i]);
	int ans = 1, s = 1, e = n + 1;
	fiboCase();

	//일반석 범위에서 경우의 수를 정답 변수에 계속 곱해준다.
	for (int i = 0; i < m + 1; i++) {
		if (i == m)
			ans *= fibo[e - s];
		else {
			ans *= fibo[vip[i] - s];
			s = vip[i] + 1;
		}
	}
	printf("%d\n", ans);

	return 0;
}
```

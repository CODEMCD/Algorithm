# 중량제한

## 문제 링크
- https://www.acmicpc.net/problem/1939

## 코드 분석
### 정답 구하기
- 그래프 탐색 알고리즘으로 정답을 구할려면, 최대 ```100,000 * 100,000```크기의 배열이 필요하다.
- 이는 400MB가 넘는 메모리를 사용하기 때문에, 문제에서 제한하는 메모리 128MB를 훨씬 초과하므로 해결할 수 없다.
### 정답 유추하기 - 이분 탐색을 활용한 DFS
- 모든 중량의 크기 중에서 정답은 반드시 존재하므로, 중량을 하나씩 대입해보며 답을 유추할 수 있다.
- 해당 문제의 정점과 간선의 크기로 보았을 때, 모든 중량을 순차적으로 대입한다면 시간내에 문제를 풀 수 없다.
- 그러므로, 이분 탐색을 활용하여 중량을 선택하며, 이 중량을 최소로하여 시작점부터 도착점까지 갈 수 있는지 DFS로 탐색한다.
- 시간복잡도: ```O(logM * (V+E))``` (M: 최대 크기 100,000, V: 최대 크기 10,000, E: 최대 크기 100,000)

## 소스 코드
```
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;
#define M 100001
//입력 인접 리스트
vector<vector<pair<int, int>>> map;
//방문했는지 검사
bool visited[M];
//모든 중량 저장
int weight[M];

//시작 지점에서 끝 지점까지 현재 중량이상으로 갈 수 있는지 검사한다.
bool dfs(int here, int ev, int weight) {
	visited[here] = true;
	bool res = false;
	//기저 사례: 끝점에 도달한 경우
	if (here == ev)
		return true;
	for (int i = 0; i < map[here].size(); ++i) {
		if (!visited[map[here][i].first] && weight <= map[here][i].second)
			res = dfs(map[here][i].first, ev, weight);
		if (res) return true;
	}
	return res;
}

int main(void)
{
	int n, m; scanf("%d %d", &n, &m);
	map = vector<vector<pair<int, int>>>(M);
	for (int i = 0; i < m; ++i) {
		int a, b, c; scanf("%d %d %d", &a, &b, &c);
		map[a - 1].push_back(make_pair(b - 1, c));
		map[b - 1].push_back(make_pair(a - 1, c));
		weight[i] = c;
	}
	int start, end;
	scanf("%d %d", &start, &end);
	start -= 1; end -= 1;
	sort(weight, weight + m);

	int ans = 0;
	int left = 0, right = m - 1;
	//가능한 가장 큰 중량을 찾기 위한 이분 탐색
	while (left <= right) {
		for (int i = 0; i < m; ++i)
			visited[i] = false;

		int mid = (left + right) / 2;

		//시작점에서 끝점에 도달할 수 있다면 답을 저장해두고
		//더 큰 중량으로 시도해본다.
		if (dfs(start, end, weight[mid])) {
			ans = weight[mid];
			left = mid + 1;
		}
		//시작점에서 끝점으로 도달할 수 없다면 중량을 낮춘다.
		else
			right = mid - 1;
	}
	printf("%d\n", ans);

	return 0;
}
```

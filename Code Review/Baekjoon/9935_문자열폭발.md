# 문자열 폭발

## 문제 개요

![9935](https://user-images.githubusercontent.com/34755287/42307196-a5fa7c8e-806c-11e8-85f1-6c45fe36d023.JPG)

## 테스트 케이스
1) 기본 테스트 케이스
- 입력
```
mirkovC4nizCC44
C4
```
-출력
```
mirkovniz
```

2) 결과 문자열 인덱스 관리
- 입력
```
aabbb
ab
```
- 출력
```
b
```

## 코드 분석
- string 함수의 멤버 함수인 find와 erase를 사용하였으나 시간초과가 났다.
  - 하나의 폭발 문자열을 찾을 때마다 전체 문자열을 순회하기 때문에 최대 ```500,000 * 1,000,000```정도의 연산 횟수로 예상된다.
- 스택를 활용하여 전체 문자열을 한번 순회하면서 폭발 문자열을 처리한다.
1) 결과를 출력할 문자열 배열 하나를 따로 선언한다.(인덱스를 활용하기 위해 char형으로 선언)
2) 폭발 문자열의 마지막 문자가 아닐 때, 전체 문자열 배열을 순서대로 결과 배열에 삽입한다.
3) 폭발 문자열의 마지막 문자를 만났을 때, 폭발 문자열의 크기만큼 결과 배열에서 거꾸로 순회하면서 해당 문자열이 폭발 문자열과 같은지 검사한다.
4) 만약 같다면, 폭발 문자열과 같은 해당 문자열의 첫번째 인덱스부터 다시 2번을 반복한다. (덮어쓰기)
  - 시간 복잡도는 최대 문자열 크기 * 최대 폭발 문자열 크기이고, ```1,000,000 * 36```이므로 2초안에 충분히 실행가능하다.

## 결과 코드
```
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <cstdio>
#include <string>
using namespace std;
#define N 1000001

int main(void)
{
	//1) 결과 문자열을 저장할 배열
	char ans[N] = {};
	string str;
	string boom;

	cin >> str;
	cin >> boom;

	int bsize = (int)boom.size();
	//스택포인트(sp)는 결과 문자열이 남아있는지를 검사하기위해 -1로 초기화
	int sp = -1, cp = 0, j;

	//스택
	for (int i = 0; i < (int)str.size(); i++) {
		//2) 폭발 문자열의 마지막 문자가 아닐 때
		if (str[i] != boom[bsize - 1])
			ans[++sp] = str[i];
		//3) 폭발 문자열의 마지막 문자를 만났을 때
		else {
			ans[++sp] = str[i];
			bool check = true;
			//폭발 문자열과 같은지 검사
			for (cp = sp - bsize + 1, j = 0; cp <= sp, j < bsize; cp++, j++)
				if (ans[cp] != boom[j])
					check = false;
			//같다면 스택 포인트를 폭발 문자열 첫번째 인덱스로 이동
			if (check) {
				sp = sp - bsize;
			}
		}
	}
	if (sp == -1)
		printf("FRULA\n");
	else {
		for (int i = 0; i <= sp; i++)
			printf("%c", ans[i]);
		printf("\n");
	}

	return 0;
}
```

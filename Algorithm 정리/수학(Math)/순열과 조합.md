# 순열과 조합

## 경우의 수
- 합의 법칙: 분류
  - 분류의 조건
  1. 동시에 일어나지 않음.
  2. 하나도 빠짐없이 포함되어 있어야함.
- 곱의 법칙: 동시에 일어나는 일 = 함께 일어나는 일
- 예제
```
자연수 999이하의 수 중에서 숫자 5가 포함된 수의 개수를 구하라.
1. 합의 법칙 = 분류
1) 5가 1개 있는 경우의 수 (곱의 법칙)
- 5xx = 9 * 9 = 81 * 1
- x5x = 9 * 9 = 81 * 1
- xx5 = 9 * 9 = 81 * 1
2) 5가 2개 있는 경우의 수 (곱의 법칙)
- 55x = 9 * 2 = 18
- 5x5 = 9 * 2 = 18
- x55 = 9 * 2 = 18
3) 5가 3개 있는 경우의 수 (곱의 법칙)
- 555 = 1 * 3
=> (81 + 81 + 81) + (18 + 18 + 18) + 3 = 300
```

## 순열(permutation)
- 순서 있는 나열
- ```nPr```: n개 중에서 r개를 뽑아서 일렬로 나열하는 경우의 수
- ```nPr = n! / (n-r)!```

### STL함수 next_permutation을 활용한 순열 구하기(C++)
- 기본적으로 next_permutation은 ```nPn```을 구하는 함수이다.
- ```nPr```을 next_permutation을 활용하여 구할려면 ```nPn```을 구한 상태에서 ```r```크기까지만 저장한다.
  - 하지만, ```nPn```과 시간복잡도가 같고, 중복으로 저장된다는 단점이 있다.
- 예제: n = 3, r = 3 일때

___예제 코드___
```
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;
vector<int> num;

int main()
{
	int n = 3;

	for (int i = 1; i <= n; ++i)
		num.push_back(i);

	int count = 0;
	do {
		for (int i = 0; i < n; ++i)
			printf("%d ", num[i]);
		printf("\n");
		count++;
	} while (next_permutation(num.begin(), num.end()));
	printf("n = %d, nPn = %d\n", n, count);

	return 0;
}
```

___실행 결과___
```
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
n = 3, nPn = 6
```


## 조합(combination)
- 순서를 고려하지 않고 선택하는 방법의 수
- ```nCr```: n개 중에서 r개를 순서에 상관없이 선택하는 방법의 수
- ``` nCr = nPr / r! = n! / (n-r)!r! ```

### STL함수 next_permutation을 활용한 조합 구하기(C++)
- ```1Cn, 2Cn, ... nCn```을 모두 구할 수 있다.
- 예제: n = 3, r = 1, 2, 3 일때

___예제 코드___
```
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;
vector<int> flag;

int main()
{
	int n = 3;

	for (int i = 1; i <= n; ++i) {
		flag.clear();
		for (int j = 0; j < n - i; ++j)
			flag.push_back(0);
		for (int j = 0; j < i; ++j)
			flag.push_back(1);
		int count = 0;
		do {
			for (int j = 0; j < n; ++j)
				if (flag[j])
					printf("%d ", j + 1);
			printf("\n");
			count++;
		} while (next_permutation(flag.begin(), flag.end()));
		printf("n = %d r = %d, nCr = %d\n", n, i, count);
	}

	return 0;
}

```

___실행 결과___
```
3
2
1
n = 3 r = 1, nCr = 3
2 3
1 3
1 2
n = 3 r = 2, nCr = 3
1 2 3
n = 3 r = 3, nCr = 1
```

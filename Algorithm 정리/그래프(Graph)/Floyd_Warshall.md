# 플로이드 - 워셜 알고리즘 (Floyd - Warshall Algorithm)

### 정의
- 그래프에서 모든 정점 사이의 최단 경로 거리를 구하는 알고리즘이다.
- 음수 가중치를 갖는 간선도 사이클만 없다면 계산 가능하다.
- 다이나믹 프로그래밍(DP)를 이용하여 구현한다.
- Optimal Substructure 개념을 활용한다.
(Optimal Substructure이란, 특정 경로안에 무수히 많은 경로가 있을 때, 중간 정점들이 각각 최단 거리가 된다면 이를 모두 이은 경로 또한 최단 거리가 된다.)

### 이해
- 2개의 테이블 사용<br> 1) 모른 경로에 대한 비용을 저장하는 테이블 (D)<br> 2) 각 정점까지 가기 직전의 정점을 저장한 테이블 (P)

![fwa](https://user-images.githubusercontent.com/34755287/38462866-6eae5022-3b28-11e8-8750-1b9ebcbc29e0.JPG)

- 초기 테이블 (인접리스트의 정보만 저장되어 있음)
1) 거리를 저장한 테이블 D

|  | 1 | 2 | 3 | 4 | 5 | 
|:------:|:------:|:------:|:------:|:------:|:------:|
|   1    |   0    |   3    |   8    |   INF    |   -4    |
|   2    |   INF    |   0    |   INF    |   1    |   7    |
|   3    |   INF    |   4    |   0    |   INF    |   INF    |
|   4    |   2    |   INF    |   -5    |   0    |   INF    |
|   5    |   INF    |   INF    |   INF    |   6    |   0    |

2) 직전 정점을 저장한 테이블 P

|  | 1 | 2 | 3 | 4 | 5 | 
|:------:|:------:|:------:|:------:|:------:|:------:|
|   1    |   NIL    |   1    |   1    |   NIL    |   1    |
|   2    |   NIL    |   NIL    |   NIL    |   2    |   2    |
|   3    |   NIL    |   3    |   NIL    |   NIL    |   NIL    |
|   4    |   4    |   NIL    |   4    |   NIL    |   NIL    |
|   5    |   NIL    |   NIL    |   NIL    |   5    |   NIL    |

INF : 무한대, NIL : 없다

- 경로 '1'을 중간 경로로 하는 테이블<br>(예를 들어, 4 -> 2 에서 4 -> 1 -> 2, 4 -> 5 에서 4 -> 1 -> 5 )

1) 중간 경로 '1'을 추가한 테이블 D

|  | 1 | 2 | 3 | 4 | 5 | 
|:------:|:------:|:------:|:------:|:------:|:------:|
|   1    |   0    |   3    |   8    |   INF    |   -4    |
|   2    |   INF    |   0    |   INF    |   1    |   7    |
|   3    |   INF    |   4    |   0    |   INF    |   INF    |
|   4    |   2    |   5    |   -5    |   0    |   -2    |
|   5    |   INF    |   INF    |   INF    |   6    |   0    |

2) 중간 경로 '1'을 추가한 테이블 P

|  | 1 | 2 | 3 | 4 | 5 | 
|:------:|:------:|:------:|:------:|:------:|:------:|
|   1    |   NIL    |   1    |   1    |   NIL    |   1    |
|   2    |   NIL    |   NIL    |   NIL    |   2    |   2    |
|   3    |   NIL    |   3    |   NIL    |   NIL    |   NIL    |
|   4    |   4    |   1    |   4    |   NIL    |   1    |
|   5    |   NIL    |   NIL    |   NIL    |   5    |   NIL    |

- 위의 과정을 모든 정점이 경로에 추가될 때까지 반복한다.
- D 테이블의 값들이 각각 최단 경로 값이 된다.
- 즉 다음과 같은 관계가 성립된다.

![fwar](https://user-images.githubusercontent.com/34755287/38462970-e6b283bc-3b29-11e8-81df-62c9b863729c.JPG)

### 구현
- 다이나믹 프로그래밍 기반이다.
- 하나의 테이블을 사용하여 단순화 한다.
- 초기화에 주의한다. (단방향, 양방향, 무한대값 설정 등)
~~~
for (int k = 1; k <= N; ++k) {  // 중간 경로 정점
	for (int i = 1; i <= N; ++i) {  // 시작 정점
	       for (int j = 1; j <= N; ++j) {  // 도착 정점
	               if (DP[i][j] > DP[i][k] + DP[k][j]) {  //최단 경로 저장
	                       DP[i][j] = DP[i][k] + DP[k][j];
	               }
	       }
	}
}
~~~
한 시작점과 도착점 사이의 모든 정점을 순회하여 최단 경로를 계산한다.
- 핵심 알고리즘 예제
~~~
if (DP[i][j] > DP[i][k] + DP[k][j]) {  //최단 경로 저장
       DP[i][j] = DP[i][k] + DP[k][j];
}
~~~

| DP | [1] | [4] | = | DP | [1] | [k] | + | DP | [k] | [j] | |  
|:------:|:------:|:------:|:------:|:------:|:------:|:------:|:------:|:------:|:------:|:------:|:------:|
|       |       |       |       |       |   1    | **1** | | | **1** | 4 | |
|       |       |       |       |       |   1    | **2** | | | **2** | 4 | 1 -> 2 -> 4 |
|       |       |       |       |       |   1    | **3** | | | **3** | 4 | 1 -> 3 -> 4 |
|       |       |       |       |       |   1    | **4** | | | **4** | 4 | |
